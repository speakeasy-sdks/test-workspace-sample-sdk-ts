/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as errors from "../sdk/models/errors";
import * as operations from "../sdk/models/operations";
import axios from "axios";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse, RawAxiosRequestHeaders } from "axios";

/**
 * Contains the list of servers available to the SDK
 */
export const ServerList = [
    /**
     * Sandbox Environment
     */
    "https://sandbox.api.of.ayoconnect.id",
] as const;

/**
 * The available configuration options for the SDK
 */
export type SDKProps = {
    /**
     * Allows overriding the default axios client used by the SDK
     */
    defaultClient?: AxiosInstance;

    /**
     * Allows overriding the default server used by the SDK
     */
    serverIdx?: number;

    /**
     * Allows overriding the default server URL used by the SDK
     */
    serverURL?: string;
    /**
     * Allows overriding the default retry config used by the SDK
     */
    retryConfig?: utils.RetryConfig;
};

export class SDKConfiguration {
    defaultClient: AxiosInstance;
    serverURL: string;
    serverDefaults: any;
    language = "typescript";
    openapiDocVersion = "1.0.0";
    sdkVersion = "0.3.0";
    genVersion = "2.213.3";
    userAgent = "speakeasy-sdk/typescript 0.3.0 2.213.3 1.0.0 Whitelabel-E-wallet";
    retryConfig?: utils.RetryConfig;
    public constructor(init?: Partial<SDKConfiguration>) {
        Object.assign(this, init);
    }
}

/**
 * Whitelabel E-wallet: Ayoconnect Whitelabel E-wallet SNAP APIs helps clients to manage and track an internal wallet for its users - which can be used for payments within client's ecosystem.
 *
 * @remarks
 *
 * ## Credentials
 *   <p>Before starting Whitelabel E-Wallet SNAP APIs integration client must ensure that they have all the required credentials. Every client will receive unique set of credentials from Ayoconnect during onboarding process.</p>
 *
 *   | Credentials    | Description                                                                                                                                       | Source                  |
 *   |---------------|---------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------|
 *   | merchantId  | Unique identifier of the client in Ayoconnect system.                                                                                            | Provided by Ayoconnect. |
 *   | client_id     | Unique 32 character string used to generate B2B and B2B2C Tokens.                                                                                 | Provided by Ayoconnect. |
 *   | client_secret | Unique 32 character string used to generate signature.                                                                                            | Provided by Ayoconnect. |
 *   | Public Key    | RSA Public key. Method to generate a valid key pair as mentioned below. Public key needs to be shared by partner during their onboarding process. | Generated by partner.   |
 *   | Private Key   | RSA Private key. Method to generate a valid key pair as mentioned below.                                                                          | Generated by partner.   |
 *
 *   ### RSA Key Pair Generation
 *   1. Generate a private key with the correct length using ```openssl genrsa -out private-key.pem 3072```
 *   2. Generate corresponding public key using ```openssl rsa -in private-key.pem -pubout -out public-key.pem```
 *
 *   ## Authentication
 *   All API requests must contain *Authorization Token* in header which is used to authenticate the client.
 *
 *   There are two types of Authorization Tokens :
 *   1. **B2B Token**
 *       Generated Using **Generate B2B Access Token** `/wallet/api/v1.0/access-token/b2b` and passed in header `Authorization` as Bearer Token. B2B Token is mandatory in all API requests.
 *
 *       ```
 *       Authorization : Bearer <b2b_token>
 *       ```
 *   2. **B2B2C Token**
 *       Generated Using **Generate B2B2C Access Token** `/wallet/api/v1.0/access-token/b2b2c` and passed in header `Authorization-Customer` as Bearer Token. B2B2c Token is mandatory in all transaction API requests.
 *
 *       ```
 *       Authorization-Customer : Bearer <b2b2c_token>
 *       ```
 *
 *   <p>Authentication Tokens (B2B or B2B2C) generate once are <b>only valid for 3600 seconds</b>, after that a new token must be generated.</p>
 *   <h2>Signature Generation</h2>
 *   <p>All API requests must contain a valid signature header. Signature is passed in <b>X-Signature</b> header of HTTP Request. Signature
 *   generation algorithm and contents to sign dependes on the API being called. Below table mentions the APIs, signature algorithm and content to sign. </p>
 *
 *   | Signature Algorithm         | Content to Sign                                                                                                         | Key to SIgn  | API Name                  |
 *   |-----------------------------|-------------------------------------------------------------------------------------------------------------------------|--------------|---------------------------|
 *   | SHA256withRSA               | <code>client_ID + "&#124;" + X- TIMESTAMP</code>                                                                        | privateKey   | Generate B2B Access Token |
 *   |                             |                                                                                                                         |              |Generate B2B2C Access Token|
 *   | HMAC_SHA512                 | <code>HTTPMethod +":"+ EndpointUrl +":"+ AccessToken +":"+ Lowercase(HexEncode(SHA-256(minify(RequestBody))))+":" + TimeStamp </code>| clientSecret                |
 *
 *
 *   <h3>Signature Generation Example</h3>
 *
 *   | Credential    | Value                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
 *   |---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 *   | client_id     | <code>fceda4da-ae95-4d14-8cb6-eef392139a1b</code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
 *   | client_secret | <code>fceda4da-ae95-4d14-8cb6-eef392139a2c</code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
 *   | private_key   | <code>-----BEGIN RSA PRIVATE KEY-----<br>MIIBOgIBAAJBAJ9wKHG/JDCr+6eZ6as5hHspDhZEUkveTF9GnCcDqRVmS/E4rhYw<br>niRfSSf2hfp516cYpC7zJ2AFB4id63T3lxECAwEAAQJALk7qQFdvEH/zYPOwTd4v<br>34HGKKuBZ63Sat3cXuyOQLt3OSj/lgRx/XELRjdLMADQrxTI0ijUvr9jqLB0I6O1<br>DQIhAMo3voVyYA0dmZvNWPRf6JzkFeexsXKmsrpNij9pwvPHAiEAyde1FPNTAeQn<br>e0DW+gtE5dHg/omiZDYBKLBj4jb4bmcCIDhvSjqP6wJ+CkqTCopY4eA3P23EB5PJ<br>tgOMdFKyP3gtAiEAgC0db2p94guTDvBEFJGndRJtAPdCSsUIw2AQbg1egi0CIH+a<br>Z4Mar+3f+SFIElF+M+aD4AzzibGUJghJ03cbR6Pt<br>-----END RSA PRIVATE KEY-----</code> |
 *   | public_key    | <code>-----BEGIN PUBLIC KEY-----<br>MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBAJ9wKHG/JDCr+6eZ6as5hHspDhZEUkve<br>TF9GnCcDqRVmS/E4rhYwniRfSSf2hfp516cYpC7zJ2AFB4id63T3lxECAwEAAQ==<br>-----END PUBLIC KEY-----</code>                                                                                                                                                                                                                                                                                                                   |
 *
 *
 *   <p>Below are the examples for <b>Signature Generation</b> which are generated using above dummy credentials. Please do not try to use above credentials, they are just for reference.</p>
 *   <ul>
 *   <li>
 *     <h3>SHA256WithRSA</h3>
 *
 *   |                                 |                                                                                                                                               |
 *   |---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------|
 *   | String Format                   | <code>client_ID + "&#124;" + X- TIMESTAMP</code>                                                                                              |
 *   | client_id                       | <code>fceda4da-ae95-4d14-8cb6-eef392139a1b</code>                                                                                             |
 *   | X- TIMESTAMP                    | <code>2023-03-28T22:13:27+07:00</code>                                                                                                        |
 *   | String to Sign                  | <code>fceda4da-ae95-4d14-8cb6-eef392139a1b&#124;2023-03-28T22:13:27+07:00</code>                                                              |
 *   | Hex Encoded Generated Signature | <code>2729b693fb377029422605c74a7f8d7c0769c6f733450ed9602b8152104328d47010bb88bb46a1e72b23ca2946c1807f753b60a38a53a6fd4e8e4cea8d26d6c8</code> |
 *
 *
 *   </li>
 *   <li>
 *     <h3>HMAC_SHA512</h3>
 *
 *   |                               |                                                                                                                                                                       |
 *   |-------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
 *   | String Format                 | <code>http_method + “:” + url_path + ”:” + access_token + ”:” +Lowercase(HexEncode(SHA256(minify(RequestBody))))+ ”:” + timestamp</code>                                           |
 *   | http_method                   | <code>POST</code>                                                                                                                                                                  |
 *   | url_path                      | <code>/api/v2/registration-account-binding</code>                                                                                                                                  |
 *   | access_token                  | <code>ed8f7f42a6d741fbb891bae654e81678</code>                                                                                                                                      |
 *   | JSON Body                     | <code>{"partnerReferenceNo": "qic5taezfgta7yhn74u7cppr47wan027",   "authCode": "8ecx3bnfk9bu2o4y0z8ur8pfhH12eltF",   "merchantId": "AYOPOP"}</code>                             |
 *   | Minified JSON Body             | <code>{"partnerReferenceNo":"qic5taezfgta7yhn74u7cppr47wan027","authCode":"8ecx3bnfk9bu2o4y0z8ur8pfhH12eltF","merchantId":"AYOPOP"}</code>                                         |
 *   | timestamp                     | <code>2023-03-28T22:13:27+07:00</code>                                                                                                                                             |
 *   | String to Sign                | <code>POST:/api/v2/registration-account-binding:ed8f7f42a6d741fbb891bae654e81678:626c42bf3d17e3a02bcabd6d265103135b6dd70e7af6341e87c56ad3650015ee:2023-03-28T22:13:27+07:00</code> |
 *   | client_secret                 | <code>fceda4da-ae95-4d14-8cb6-eef392139a2c</code>                                                                                                                                  |
 *   | Encryption With client_secret | <code>2e955289baf7f297dda75b830c00f15b81a71710c2d0a0bbdf5884ae15bf47bb46e627a0b25cff1c1da16c42682ec69945950a1b120b6be490a53b7d613cf7e4</code>                                      |
 *
 *
 *   </li>
 *   </ul>
 *
 * API FLOWS:
 * 1. Account Creation - Customer Wallet
 * 2. Top Up - Customer Wallet
 * 3. Withdrawal - Customer Wallet
 * 4. Balance Inquiry
 *
 * ## Account Creation Flow
 *   <p><img src="https://storage.cloud.google.com/api_spec_assets/image-20230418-213251.png"/></p>
 *
 * ## Top Up Flow
 *   ### Top Up Inquiry
 *   <p><img src="https://storage.cloud.google.com/api_spec_assets/4_15_sequence_diagram_api_account_inquiry_-_customer_top_up.png"/></p>
 *
 *   ### Top Up
 *   <p><img src="https://storage.cloud.google.com/api_spec_assets/4_16_sequence_diagram_api_customer_top_up.png"/></p>
 *
 *   ### Top Up Inquiry Status
 *   <p><img src="https://storage.cloud.google.com/api_spec_assets/4_17_sequence_diagram_api_customer_top_up_inquiry_status.png"/></p>
 *
 * ## Withdrawal Flow
 *   <p><img src="https://storage.cloud.google.com/api_spec_assets/Web_Photo_Editor.jpg"/></p>
 *
 */
export class WhitelabelEWallet {
    private sdkConfiguration: SDKConfiguration;

    constructor(props?: SDKProps) {
        let serverURL = props?.serverURL;
        const serverIdx = props?.serverIdx ?? 0;

        if (!serverURL) {
            serverURL = ServerList[serverIdx];
        }

        const defaultClient = props?.defaultClient ?? axios.create();
        this.sdkConfiguration = new SDKConfiguration({
            defaultClient: defaultClient,
            serverURL: serverURL,
            retryConfig: props?.retryConfig,
        });
    }

    /**
     * Account Binding
     *
     * @remarks
     * Account Binding
     */
    async accountBinding(
        req: operations.AccountBindingRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AccountBindingResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AccountBindingRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/registration-account-binding";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AccountBindingResponse = new operations.AccountBindingResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Account Creation
     *
     * @remarks
     * Account CreationÐ
     */
    async accountCreation(
        req: operations.AccountCreationRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AccountCreationResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AccountCreationRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/registration-account-creation";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AccountCreationResponse = new operations.AccountCreationResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
        });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(responseContentType, `application/json`)) {
                    res.object = utils.objectToClass(
                        JSON.parse(decodedRes),
                        operations.AccountCreationResponseBody
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + responseContentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    decodedRes,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Auth Capture - withdraw
     *
     * @remarks
     * Auth Capture - withdraw
     */
    async authCaptureWithdraw(
        req: operations.AuthCaptureWithdrawRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AuthCaptureWithdrawResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AuthCaptureWithdrawRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/auth/capture";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AuthCaptureWithdrawResponse =
            new operations.AuthCaptureWithdrawResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Auth Payment - withdraw
     *
     * @remarks
     * Auth Payment - withdraw
     */
    async authPaymentWithdraw(
        req: operations.AuthPaymentWithdrawRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AuthPaymentWithdrawResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AuthPaymentWithdrawRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/auth/payment";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AuthPaymentWithdrawResponse =
            new operations.AuthPaymentWithdrawResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Auth Query - withdraw
     *
     * @remarks
     * Auth Query - withdraw
     */
    async authQueryWithdraw(
        req: operations.AuthQueryWithdrawRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AuthQueryWithdrawResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AuthQueryWithdrawRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/auth/query";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AuthQueryWithdrawResponse = new operations.AuthQueryWithdrawResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Auth Refund - withdraw
     *
     * @remarks
     * Auth Refund - withdraw
     */
    async authRefundWithdraw(
        req: operations.AuthRefundWithdrawRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AuthRefundWithdrawResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AuthRefundWithdrawRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/auth/refund";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AuthRefundWithdrawResponse =
            new operations.AuthRefundWithdrawResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Auth Void - withdraw
     *
     * @remarks
     * Auth Void - withdraw
     */
    async authVoidWithdraw(
        req: operations.AuthVoidWithdrawRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.AuthVoidWithdrawResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.AuthVoidWithdrawRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/auth/void";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.AuthVoidWithdrawResponse = new operations.AuthVoidWithdrawResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Generate B2B2C token
     *
     * @remarks
     * This API generates access token used in TopUp & Withdrawal flow.
     */
    async generateB2b2cToken(
        req: operations.GenerateB2b2cTokenRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.GenerateB2b2cTokenResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GenerateB2b2cTokenRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/access-token/b2b2c";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GenerateB2b2cTokenResponse =
            new operations.GenerateB2b2cTokenResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
                headers: utils.getHeadersFromResponse(httpRes.headers),
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(responseContentType, `application/json`)) {
                    res.object = utils.objectToClass(
                        JSON.parse(decodedRes),
                        operations.GenerateB2b2cTokenResponseBody
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + responseContentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    decodedRes,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Generate B2B Access token
     *
     * @remarks
     * This API generates access token used in Authorization Headers of Customer Registration, TopUp & Withdrawal flow requests.
     */
    async generateB2bToken(
        req: operations.GenerateB2bTokenRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.GenerateB2bTokenResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GenerateB2bTokenRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/access-token/b2b";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GenerateB2bTokenResponse = new operations.GenerateB2bTokenResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
            headers: utils.getHeadersFromResponse(httpRes.headers),
        });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(responseContentType, `application/json`)) {
                    res.object = utils.objectToClass(
                        JSON.parse(decodedRes),
                        operations.GenerateB2bTokenResponseBody
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + responseContentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    decodedRes,
                    httpRes
                );
        }

        return res;
    }

    /**
     * Generate WebView
     *
     * @remarks
     * Generate WebView
     */
    async generateWebview(
        req: operations.GenerateWebviewRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.GenerateWebviewResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GenerateWebviewRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/registration-account-webview";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GenerateWebviewResponse = new operations.GenerateWebviewResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * OTP Verification
     *
     * @remarks
     * OTP Verification
     */
    async otpVerification(
        req: operations.OtpVerificationRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.OtpVerificationResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.OtpVerificationRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/otp-verification";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.OtpVerificationResponse = new operations.OtpVerificationResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * TopUp
     *
     * @remarks
     * TopUp
     */
    async topup(
        req: operations.TopupRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TopupResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TopupRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/emoney/topup";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TopupResponse = new operations.TopupResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * TopUp- Inquiry
     *
     * @remarks
     * TopUp- Inquiry
     */
    async topupInquiry(
        req: operations.TopupInquiryRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TopupInquiryResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TopupInquiryRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/emoney/account-inquiry";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TopupInquiryResponse = new operations.TopupInquiryResponse({
            statusCode: httpRes.status,
            contentType: responseContentType,
            rawResponse: httpRes,
        });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * TopUp - Inquiry Status
     *
     * @remarks
     * TopUp - Inquiry Status
     */
    async topupInquiryStatus(
        req: operations.TopupInquiryStatusRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.TopupInquiryStatusResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.TopupInquiryStatusRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/emoney/topup-status";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.TopupInquiryStatusResponse =
            new operations.TopupInquiryStatusResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * WalletBalance - Customer Merchant
     *
     * @remarks
     * WalletBalance - Customer Merchant
     */
    async walletbalanceCustomerMerchant(
        req: operations.WalletbalanceCustomerMerchantRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.WalletbalanceCustomerMerchantResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.WalletbalanceCustomerMerchantRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/balance-inquiry/customer-merchant";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.WalletbalanceCustomerMerchantResponse =
            new operations.WalletbalanceCustomerMerchantResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }

    /**
     * WalletBalance - Merchant
     *
     * @remarks
     * WalletBalance - Merchant
     */
    async walletbalanceMerchant(
        req: operations.WalletbalanceMerchantRequest,
        config?: AxiosRequestConfig
    ): Promise<operations.WalletbalanceMerchantResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.WalletbalanceMerchantRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string =
            baseURL.replace(/\/$/, "") + "/wallet/api/v1.0/balance-inquiry/merchant";

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "requestBody", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        const headers: RawAxiosRequestHeaders = {
            ...utils.getHeadersFromRequest(req),
            ...reqBodyHeaders,
            ...config?.headers,
        };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const responseContentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.WalletbalanceMerchantResponse =
            new operations.WalletbalanceMerchantResponse({
                statusCode: httpRes.status,
                contentType: responseContentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
            case (httpRes?.status >= 400 && httpRes?.status < 500) ||
                (httpRes?.status >= 500 && httpRes?.status < 600):
                throw new errors.SDKError(
                    "API error occurred",
                    httpRes.status,
                    httpRes?.data,
                    httpRes
                );
        }

        return res;
    }
}
